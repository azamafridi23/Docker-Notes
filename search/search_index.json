{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Obsidian Notes","text":""},{"location":"#table-of-content","title":"Table of Content","text":"<ul> <li>Docker Intro</li> <li>Docker Image</li> <li>Docker Container</li> <li>Docker Volume</li> <li>Docker Network</li> <li>Docker Workflow</li> <li>Docker Background</li> <li>Dockerfile</li> <li>Registry</li> <li>Containerization</li> <li>Docker vs VM</li> <li>Docker Kernel Sharing</li> <li>Advanced Topics</li> <li>Security Considerations </li> <li>Docker Compose</li> <li>Multi Stage Builds in Docker</li> </ul>"},{"location":"Advanced%20Topics/","title":"Advanced Topics","text":"<ol> <li> <p>Docker Compose: Docker Compose is a tool for defining and running multi-container Docker applications. It allows you to use a YAML file to configure the services that make up your application and run them with a single command.</p> </li> <li> <p>Docker Swarm: Docker Swarm is a native clustering and orchestration tool for Docker. It allows you to create and manage a cluster of Docker hosts, making it easy to deploy and scale applications across multiple hosts.</p> </li> <li> <p>Docker Networking: Docker provides networking features that allow containers to communicate with each other and with other services outside the container.</p> </li> <li> <p>Docker Volumes: Docker volumes are used to persist data generated by and used by Docker containers. Volumes allow you to share data between containers and persist data even if the container is stopped or deleted.</p> </li> </ol>"},{"location":"Containerization/","title":"Containerization","text":"<p>The process of packaging an application and its dependencies into isolated containers. Each container runs a separate instance of the application, isolated from others and from the host system.</p>"},{"location":"Docker%20Background/","title":"Docker Background","text":"<ul> <li>The Docker client, often simply referred to as <code>docker</code>, is the primary interface through which users interact with the Docker Engine. It provides a command-line interface (CLI) that allows users to manage Docker containers, images, volumes, networks, and other Docker objects.</li> <li>The Docker host is the physical or virtual machine where the Docker Engine runs. It's responsible for managing and running Docker containers.</li> <li>The Docker registry is a storage and distribution system for Docker images. It's where Docker users can store and share Docker images with others.</li> </ul>"},{"location":"Docker%20Compose/","title":"Docker Compose","text":"<p>Docker Compose is a tool used to define and manage multi-container Docker applications. It allows developers to define a multi-container application in a single file (usually named docker-compose.yml) and then use a single command to spin up all the services defined in that file.</p> <p>Here's why Docker Compose is required and how it works with some examples:</p> <ol> <li> <p>Managing Complex Applications: In modern software development, applications are often composed of multiple services, each running in its own container. These services might include databases, web servers, caches, message brokers, etc. Managing all these containers individually can be cumbersome. Docker Compose simplifies this process by allowing developers to define the services and their configurations in a single file.</p> </li> <li> <p>Simplified Deployment: With Docker Compose, deploying a multi-container application becomes much easier. Instead of manually starting each container with its respective configuration, developers can use a single command (<code>docker-compose up</code>) to start all the services defined in the compose file.</p> </li> <li> <p>Service Orchestration: Docker Compose provides a way to define the relationships and dependencies between different services in a compose file. For example, you can specify that a web server container depends on a database container. Docker Compose ensures that these dependencies are resolved properly when starting or stopping containers.</p> </li> </ol> <p>Here's an example of a simple <code>docker-compose.yml</code> file:</p> <pre><code>version: '3'\n\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"8080:80\"\n  db:\n    image: mysql:latest\n    environment:\n      MYSQL_ROOT_PASSWORD: example\n      MYSQL_DATABASE: myapp\n</code></pre> <p>In this example, we define two services: a web server (<code>web</code>) using the Nginx image and a database (<code>db</code>) using the MySQL image. The <code>ports</code> directive exposes port 80 of the web server container to port 8080 on the host machine. The <code>environment</code> directive sets some environment variables required by the MySQL container.</p> <p>To start these services, you simply navigate to the directory containing the <code>docker-compose.yml</code> file and run:</p> <pre><code>docker-compose up\n</code></pre> <p>Docker Compose will then pull the necessary images (if not already present), create the containers, and start them according to the configurations specified in the compose file.</p>"},{"location":"Docker%20Compose/#in-summary-docker-compose-simplifies-the-process-of-managing-multi-container-docker-applications-by-allowing-developers-to-define-and-orchestrate-their-services-using-a-single-configuration-file","title":"In summary, Docker Compose simplifies the process of managing multi-container Docker applications by allowing developers to define and orchestrate their services using a single configuration file.","text":""},{"location":"Docker%20Container/","title":"Docker Container","text":"<p>A Docker container is a runtime environment with all the necessary components\u2014like code, dependencies, and libraries\u2014needed to run the application code without using host machine dependencies. This container runtime runs on the engine on a server, machine, or cloud instance. The engine runs multiple containers depending on the underlying resources available.\u00a0</p> <p>To deploy and scale a set of containers to communicate effectively across different machines or virtual machines, you need a container orchestration platform like Kubernetes. This helps whether your machines are on premises or in the cloud. Kubernetes manages multiple machines, known as a cluster, within the context of container operations.</p>"},{"location":"Docker%20Container/#in-depth","title":"In depth:","text":"<p>Docker container is essentially a lightweight, standalone, and executable package that includes everything needed to run a piece of software, and it is built from Docker images.</p> <p>To understand the relationship between Docker containers and images, it's important to understand the concept of layers:</p>"},{"location":"Docker%20Container/#docker-image-layers","title":"Docker Image Layers:","text":"<p>Docker images are composed of multiple layers. Each layer represents a set of filesystem changes or instructions that were applied during the image's creation. Layers are immutable, meaning they cannot be modified after they are created.</p> <p>When you build a Docker image using a Dockerfile, each instruction in the Dockerfile adds a new layer to the image. For example, the <code>RUN</code> instruction installs software packages, the <code>COPY</code> instruction copies files into the image, and so on.</p>"},{"location":"Docker%20Container/#docker-container","title":"Docker Container:","text":"<p>A Docker container is a runtime instance of a Docker image. When you run a Docker container, Docker creates a writable container layer on top of the image's read-only layers. This container layer is ephemeral and exists only as long as the container is running.</p> <p>The container layer allows changes made to the filesystem during the container's execution, such as writing to files or creating new files, to be isolated from the underlying image layers. This enables containers to be lightweight, portable, and disposable.</p>"},{"location":"Docker%20Container/#relationship","title":"Relationship:","text":"<ul> <li> <p>Image Layers: Docker images consist of multiple layers representing filesystem changes or instructions. These layers are immutable and are shared among containers based on the same image.</p> </li> <li> <p>Container Layer: When a Docker container is run, a writable container layer is created on top of the image's read-only layers. This layer captures any changes made to the filesystem during the container's execution.</p> </li> </ul> <p>In summary, a Docker container is not a layer of images but rather an instance of a Docker image with a writable container layer on top. The container layer allows containers to be ephemeral and isolated from the underlying image layers, providing a lightweight and portable runtime environment for applications.</p> <p></p>"},{"location":"Docker%20Image/","title":"Docker Image","text":"<p>A Docker image, or container image, is a standalone, executable file used to create a container. This container image contains all the libraries, dependencies, and files that the container needs to run. A Docker image is shareable and portable, so you can deploy the same image in multiple locations at once\u2014much like a software binary file.\u00a0</p> <p>You can store images in registries to keep track of complex software architectures, projects, business segments, and user group access. For instance, the public Docker Hub registry contains images such as operating systems, programming language frameworks, databases, and code editors.</p>"},{"location":"Docker%20Intro/","title":"Docker Intro","text":"<p>Docker is a tool designed to make it easier to create, deploy, and run applications by using containers. Containers allow developers to package an application with all of its dependencies into a standardized unit for software development, which includes everything needed to run it: code, runtime, system tools, system libraries, etc. This ensures that the application runs seamlessly across different computing environments, from development to testing to production.</p>"},{"location":"Docker%20Kernel%20Sharing/","title":"Docker Kernel Sharing","text":"<p>Docker containers do not have their own kernel; instead, they share the kernel of the host operating system. This is a fundamental aspect of containerization and distinguishes containers from virtual machines (VMs), which typically run with their own separate kernels.</p> <p>Here's a more detailed explanation of how Docker containers share the kernel of the host operating system:</p>"},{"location":"Docker%20Kernel%20Sharing/#kernel-sharing","title":"Kernel Sharing:","text":"<ol> <li> <p>Host Kernel: Docker containers run on a host operating system (Linux, Windows, or macOS), and they share the same kernel as the host. This means that containers do not require a separate operating system installation like virtual machines.</p> </li> <li> <p>Kernel Namespaces: Docker leverages Linux kernel namespaces to provide process-level isolation between containers. Namespaces allow containers to have their own view of system resources such as process IDs, network interfaces, user IDs, and mount points.</p> </li> <li> <p>Control Groups (cgroups): Docker also uses control groups (cgroups) to enforce resource constraints and limits on containers. Cgroups allow Docker to allocate CPU, memory, disk I/O, and network bandwidth resources to containers, ensuring fair and efficient resource usage.</p> </li> </ol>"},{"location":"Docker%20Kernel%20Sharing/#benefits-of-kernel-sharing","title":"Benefits of Kernel Sharing:","text":"<ol> <li> <p>Resource Efficiency: Sharing the host kernel reduces resource overhead compared to virtual machines, as containers do not require a separate operating system installation. This allows for higher density of containers on a single host and better resource utilization.</p> </li> <li> <p>Fast Startup: Containers start up quickly because they do not need to boot a separate kernel. Instead, they leverage the existing kernel of the host operating system, enabling containers to launch in seconds.</p> </li> <li> <p>Consistent Environment: Containers running on the same host share the same kernel and system libraries, providing a consistent environment for running applications across different containers. This simplifies application deployment and ensures compatibility.</p> </li> </ol>"},{"location":"Docker%20Kernel%20Sharing/#isolation","title":"Isolation:","text":"<p>While Docker containers share the same kernel, they are still isolated from each other and the host system using various Linux kernel features such as namespaces and cgroups. Each container has its own filesystem, network stack, process space, and set of resources, providing process-level isolation similar to virtualization but with lower overhead.</p>"},{"location":"Docker%20Kernel%20Sharing/#conclusion","title":"Conclusion:","text":"<p>In summary, Docker containers share the kernel of the host operating system, which allows for efficient resource usage, fast startup times, and consistent environments. By leveraging Linux kernel features such as namespaces and cgroups, Docker provides process-level isolation between containers while maximizing resource utilization and performance. Understanding how Docker containers share the kernel is essential for effectively designing, deploying, and managing containerized applications.</p>"},{"location":"Docker%20Network/","title":"Docker Network","text":"<p>Docker networks are a fundamental feature that enable communication between Docker containers and/or between containers and the outside world. They provide isolated environments for containers to communicate securely while offering flexibility in terms of connectivity and network configurations.</p>"},{"location":"Docker%20Volume/","title":"Docker Volume","text":"<p>Docker volumes are a mechanism for persisting data generated by and used by Docker containers. They provide a way to store and share data between containers and persist data even if the container is stopped or deleted. Volumes are particularly useful for scenarios where you need to store data that should persist beyond the lifecycle of a single container, such as database storage, file uploads, or log files.</p>"},{"location":"Docker%20Workflow/","title":"Docker Workflow","text":"<ol> <li> <p>Write a Dockerfile: Create a Dockerfile that defines the steps to build your Docker image. This includes specifying a base image, adding dependencies, and setting up the environment.</p> </li> <li> <p>Build an Image: Use the <code>docker build</code> command to build your Docker image based on the Dockerfile you created.</p> </li> <li> <p>Run a Container: Once you have a Docker image, you can create and run Docker containers based on that image using the <code>docker run</code> command.</p> </li> <li> <p>Manage Containers: You can manage your Docker containers using various commands such as <code>docker ps</code> to list running containers, <code>docker stop</code> to stop a container, and <code>docker rm</code> to remove a container.</p> </li> <li> <p>Push and Pull Images: If you want to share your Docker image with others, you can push it to a registry using the <code>docker push</code> command. Similarly, you can pull Docker images from a registry using the <code>docker pull</code> command.</p> </li> </ol>"},{"location":"Docker%20vs%20VM/","title":"Docker vs VM","text":"<p>Docker and virtual machines (VMs) are both technologies used to deploy and manage applications, but they have different architectures and use cases. Here are the key differences between Docker and VMs:</p>"},{"location":"Docker%20vs%20VM/#docker","title":"Docker:","text":"<ol> <li> <p>Containerization: Docker uses containerization to package applications and their dependencies into isolated containers. Each container runs as a process on the host operating system, sharing the kernel with other containers and the host.</p> </li> <li> <p>Resource Efficiency: Containers are lightweight and consume fewer resources compared to VMs because they share the host's operating system kernel. This allows for higher density of containers on a single host, leading to better resource utilization.</p> </li> <li> <p>Portability: Docker containers are portable across different environments, as they encapsulate everything needed to run an application, including the code, runtime, libraries, and dependencies. This enables consistent deployment and execution across development, testing, and production environments.</p> </li> <li> <p>Fast Startup: Docker containers typically start up much faster than VMs, as they do not require booting a separate operating system. Containers can be launched in seconds, making them suitable for dynamic scaling and agile development workflows.</p> </li> <li> <p>Isolation: Docker containers provide process-level isolation, meaning each container runs as a separate process with its own filesystem, network, and process namespace. However, containers share the same kernel as the host, which may lead to security concerns if not properly configured.</p> </li> </ol>"},{"location":"Docker%20vs%20VM/#virtual-machines-vms","title":"Virtual Machines (VMs):","text":"<ol> <li> <p>Hypervisor-Based Virtualization: VMs use hypervisor-based virtualization to create isolated environments, each with its own complete operating system instance (Guest OS). This allows VMs to run multiple operating systems on a single physical machine.</p> </li> <li> <p>Resource Overhead: VMs have higher resource overhead compared to containers, as they include a complete Guest OS and require additional memory, storage, and CPU resources to operate. This can limit the number of VMs that can be run on a single host.</p> </li> <li> <p>Portability: VMs are less portable than Docker containers because they rely on specific Guest OS configurations. Moving VMs between different environments may require additional configuration and compatibility checks.</p> </li> <li> <p>Slow Startup: VMs typically have longer startup times compared to Docker containers, as they need to boot a separate Guest OS. Starting a VM may take minutes, depending on the Guest OS and the underlying hardware.</p> </li> <li> <p>Isolation: VMs provide stronger isolation compared to Docker containers, as each VM runs on its own Guest OS with its own kernel. This provides better security and ensures that software running inside one VM cannot affect other VMs or the host system.</p> </li> </ol>"},{"location":"Docker%20vs%20VM/#summary","title":"Summary:","text":"<p>In summary, Docker and VMs offer different levels of isolation, resource efficiency, and portability. Docker containers are lightweight, portable, and efficient, making them suitable for microservices architectures, continuous integration/continuous deployment (CI/CD) pipelines, and cloud-native applications. VMs provide stronger isolation and compatibility with legacy applications but come with higher resource overhead and slower startup times. The choice between Docker and VMs depends on the specific requirements of the application, the desired level of isolation, and the available infrastructure</p>"},{"location":"Dockerfile/","title":"Dockerfile","text":"<p>Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Essentially, it's a set of instructions used to create a Docker image. Let's delve into it in depth:</p>"},{"location":"Dockerfile/#1-understanding-docker-images","title":"1. Understanding Docker Images:","text":"<p>Docker images are the basis of containers. An image is a lightweight, standalone, and executable software package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files.</p>"},{"location":"Dockerfile/#2-basics-of-dockerfile","title":"2. Basics of Dockerfile:","text":"<ul> <li>Dockerfile is a text file that contains a set of instructions used to build Docker images.</li> <li>Each instruction in a Dockerfile creates a layer in the image.</li> </ul>"},{"location":"Dockerfile/#3-syntax","title":"3. Syntax:","text":"<ul> <li>Each instruction in a Dockerfile is a command followed by arguments.</li> <li>Comments begin with the <code>#</code> symbol.</li> <li>Instructions are not case-sensitive, though conventionally written in uppercase.</li> </ul>"},{"location":"Dockerfile/#4-common-instructions","title":"4. Common Instructions:","text":"<ul> <li><code>FROM</code>: Specifies the base image to start from. It's usually the first instruction in a Dockerfile.</li> <li><code>RUN</code>: Executes commands in a new layer on top of the current image and commits the results.</li> <li><code>COPY</code> / <code>ADD</code>: Copies files/directories from the build context (your local machine) into the image.</li> <li><code>WORKDIR</code>: Sets the working directory for any <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code>, and <code>ADD</code> instructions that follow it.</li> <li><code>EXPOSE</code>: Informs Docker that the container listens on specific network ports at runtime.</li> <li><code>CMD</code> / <code>ENTRYPOINT</code>: Specifies the command that will be executed when a container is run from the built image.</li> <li><code>ENV</code>: Sets environment variables in the image.</li> </ul>"},{"location":"Dockerfile/#5-best-practices","title":"5. Best Practices:","text":"<ul> <li>Layering: Order commands to optimize caching. Commands less likely to change should be higher in the file.</li> <li>Minimize Layers: Combine related operations to reduce the number of layers.</li> <li>Cleanup: Remove unnecessary dependencies and files after installing packages.</li> <li>Security: Avoid hardcoding sensitive information in Dockerfiles.</li> </ul>"},{"location":"Dockerfile/#6-example-dockerfile","title":"6. Example Dockerfile:","text":"<p>dockerfileCopy code</p> <p><code># Use a base image FROM ubuntu:latest  # Set working directory WORKDIR /app  # Install dependencies RUN apt-get update &amp;&amp; apt-get install -y \\     python3 \\     python3-pip  # Copy application files COPY . .  # Expose port EXPOSE 8080  # Set environment variables ENV DEBUG=True  # Command to run the application CMD [\"python3\", \"app.py\"]</code></p>"},{"location":"Dockerfile/#7-building-images","title":"7. Building Images:","text":"<ul> <li> <p>To build an image from a Dockerfile, use the <code>docker build</code> command:</p> <p>phpCopy code</p> <p><code>docker build -t &lt;image_name&gt; &lt;path_to_Dockerfile&gt;</code></p> </li> </ul>"},{"location":"Dockerfile/#8-conclusion","title":"8. Conclusion:","text":"<p>Dockerfile is a powerful tool for creating reproducible and portable Docker images. Understanding its syntax and best practices is crucial for efficient image creation and maintenance. By following these principles, you can build optimized, secure, and scalable Docker images for your applications.</p>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/","title":"Multi Stage Builds in Docker","text":"<p>Multi-stage builds in Docker allow you to use multiple <code>FROM</code> statements in your Dockerfile, each representing a separate build stage. This feature enables you to create more efficient and smaller Docker images by separating build dependencies from the final runtime environment.</p> <p>Here's a step-by-step guide to creating a Dockerfile with multi-stage builds:</p>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#1-identify-build-stages","title":"1. Identify Build Stages:","text":"<p>Determine the different stages required for building your application. Common stages include:</p> <ul> <li>Installing build dependencies</li> <li>Building the application</li> <li>Packaging the application</li> </ul>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#2-write-dockerfile","title":"2. Write Dockerfile:","text":"<p>Create a Dockerfile with multiple <code>FROM</code> statements, each defining a build stage. Use the <code>COPY --from=&lt;stage&gt;</code> directive to copy files or dependencies from one stage to another.</p> <p>Here's an example Dockerfile for a Python application:</p> <pre><code># Stage 1: Install build dependencies and compile application\nFROM python:3.10 AS builder\n\n# Install build dependencies\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y build-essential\n\n# Copy application source code\nCOPY . /app\n\n# Set working directory\nWORKDIR /app\n\n# Install application dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Stage 2: Create lightweight runtime environment\nFROM python:3.10-slim AS runtime\n\n# Copy application files from the builder stage\nCOPY --from=builder /app /app\n\n# Set working directory\nWORKDIR /app\n\n# Expose port (if required)\nEXPOSE 8000\n\n# Run application\nCMD [\"python\", \"app.py\"]\n</code></pre> <p>In this example:</p> <ul> <li>Stage 1 (builder): Installs build dependencies, copies application source code, installs application dependencies, and compiles the application (if necessary).</li> <li>Stage 2 (runtime): Creates a lightweight runtime environment by copying only the necessary files from the builder stage. This stage is optimized for running the application.</li> </ul>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#3-build-docker-image","title":"3. Build Docker Image:","text":"<p>Run <code>docker build</code> command to build the Docker image. Docker automatically executes each stage in the Dockerfile.</p> <pre><code>docker build -t myapp .\n</code></pre>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#4-run-docker-container","title":"4. Run Docker Container:","text":"<p>Once the image is built, you can run a container from it: <pre><code>docker run -p 8000:8000 myapp\n</code></pre></p>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#benefits-of-multi-stage-builds","title":"Benefits of Multi-Stage Builds:","text":"<ul> <li>Smaller image size: Only necessary dependencies and files are included in the final image, resulting in smaller image sizes.</li> <li>Better security: Build dependencies are isolated from the runtime environment, reducing the attack surface.</li> <li>Improved performance: Build artifacts are not included in the final image, resulting in faster image pull and startup times.</li> </ul>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#conclusion","title":"Conclusion:","text":"<p>Multi-stage builds in Docker provide a powerful mechanism for building efficient and optimized Docker images. By separating build stages and minimizing the size of the final image, you can create Docker images that are smaller, more secure, and faster to deploy.</p>"},{"location":"Multi%20Stage%20Builds%20in%20Docker/#in-a-multi-stage-docker-build-the-as-keyword-is-used-to-define-a-name-or-alias-for-a-build-stage-this-allows-you-to-reference-that-stage-later-in-the-dockerfile-particularly-when-copying-files-or-dependencies-from-one-stage-to-another-using-the-copy-fromstage-directive","title":"In a multi-stage Docker build, the <code>AS</code> keyword is used to define a name or alias for a build stage. This allows you to reference that stage later in the Dockerfile, particularly when copying files or dependencies from one stage to another using the <code>COPY --from=&lt;stage&gt;</code> directive.","text":"<p>Here's a breakdown of how <code>AS</code> is used and its significance in multi-stage Docker builds:</p> <ol> <li> <p>Defining Build Stages: When you use the <code>FROM</code> directive to specify a base image for a build stage, you can use <code>AS</code> to assign a name to that stage.</p> <p>Example:</p> <pre><code>FROM python:3.10 AS builder\n</code></pre> <p>In this example, <code>builder</code> is the name assigned to the build stage.</p> </li> <li> <p>Referencing Build Stages: After defining a build stage with a name using <code>AS</code>, you can reference that stage later in the Dockerfile, typically when copying files or dependencies.</p> <p>Example:</p> <pre><code>COPY --from=builder /app /app\n</code></pre> <p>Here, <code>builder</code> is the name of the previously defined build stage, and <code>/app</code> is the path from which files are copied within that stage.</p> </li> <li> <p>Copying Between Build Stages: You can also use <code>AS</code> to reference a build stage when copying files or dependencies between stages. This allows you to selectively copy only the necessary artifacts from one stage to another, reducing the size of the final image.</p> <p>Example:</p> <pre><code>COPY --from=builder /app/build /app\n</code></pre> <p>This command copies files from the <code>builder</code> stage's <code>/app/build</code> directory to the current stage's <code>/app</code> directory.</p> </li> <li> <p>Creating a Final Stage: In many cases, the last build stage is used to create the final runtime image. You can use <code>AS</code> to give this stage a meaningful name.</p> <p>Example:</p> <pre><code>FROM python:3.10 AS runtime\n</code></pre> <p>Here, <code>runtime</code> is the name assigned to the final stage, which typically includes only the necessary files and dependencies for running the application.</p> </li> </ol> <p>In summary, the <code>AS</code> keyword in multi-stage Docker builds allows you to define and reference build stages by assigning them meaningful names. This improves readability, makes it easier to copy files between stages, and helps create more efficient Docker images.</p>"},{"location":"Registry/","title":"Registry","text":"<p>A storage and distribution system for Docker images. Docker Hub is the default public registry provided by Docker, but you can also set up private registries to store your own Docker images.</p>"},{"location":"Security%20Considerations/","title":"Security Considerations","text":"<ol> <li> <p>Container Isolation: While Docker containers provide some level of isolation, they are not completely secure by default. It's important to follow security best practices such as running containers with minimal privileges and limiting their access to host resources.</p> </li> <li> <p>Image Security: Docker images should be scanned for vulnerabilities before being deployed to production environments. Tools such as Docker Security Scanning can help identify security issues in Docker images.</p> </li> <li> <p>Network Security: Docker containers should be isolated from each other and from the host system using network security measures such as firewalls and network policies.</p> </li> </ol>"},{"location":"Table%20Of%20Content/","title":"Table Of Content","text":"<ul> <li>Docker Intro</li> <li>Docker Image</li> <li>Docker Container</li> <li>Docker Volume</li> <li>Docker Network</li> <li>Docker Workflow</li> <li>Docker Background</li> <li>Dockerfile</li> <li>Registry</li> <li>Containerization</li> <li>Docker vs VM</li> <li>Docker Kernel Sharing</li> <li>Advanced Topics</li> <li>Security Considerations </li> <li>Docker Compose</li> <li>Multi Stage Builds in Docker</li> </ul>"},{"location":"base%20image/","title":"Base image","text":"<p>A base image in Docker is the starting point for creating your own Docker images. It serves as the foundation upon which you can add your application code, dependencies, and configurations to create a customized image tailored to your specific needs.</p> <p>Here are some key points about base images:</p> <ol> <li> <p>Starting Point: The base image provides the initial environment for your application. It contains an operating system (such as Ubuntu, Alpine Linux, or CentOS) along with essential system libraries and utilities.</p> </li> <li> <p>Variety: Docker offers a variety of base images optimized for different use cases. For example, there are base images for general-purpose Linux distributions, minimalistic images for reducing image size (such as Alpine Linux), and images tailored for specific programming languages or frameworks.</p> </li> <li> <p>Layering: Docker images are built in layers, and the base image forms the initial layer. When you add additional layers to the image (by installing software, copying files, etc.), each layer builds upon the previous one.</p> </li> <li> <p>Reusability: Using a base image saves time and effort, as it provides a pre-configured environment with commonly used components. You can leverage existing base images rather than starting from scratch each time you build a new image.</p> </li> <li> <p>Security: Choosing a trusted and regularly maintained base image is crucial for security. Base images provided by official Docker repositories or reputable organizations are typically vetted for security vulnerabilities and regularly updated to address any issues.</p> </li> <li> <p>Customization: While base images provide a starting point, you can customize them to suit your application's requirements. This customization may involve installing additional software packages, configuring environment variables, setting up user permissions, etc.</p> </li> <li> <p>Layered Approach: It's common practice to use multiple layers in Docker images, with the base image being the first layer. This allows for efficient image caching, as Docker can reuse unchanged layers during subsequent builds, speeding up the build process.</p> </li> </ol> <p>In summary, a base image in Docker is the initial building block for creating Docker images. By choosing an appropriate base image and customizing it to fit your needs, you can create efficient, portable, and scalable Docker images for deploying your applications.</p>"},{"location":"Features/LaTeX%20Math%20Support/","title":"LaTeX Math Support","text":"<p>LaTeX math is supported using MathJax.</p> <p>Inline math looks like \\(f(x) = x^2\\). The input for this is <code>$f(x) = x^2$</code>. Use <code>$...$</code>.</p> <p>For a block of math, use <code>$$...$$</code> on separate lines</p> <pre><code>$$\nF(x) = \\int^a_b \\frac{1}{2}x^4\n$$\n</code></pre> <p>gives </p> \\[ F(x) = \\int^a_b \\frac{1}{2}x^4 \\]"},{"location":"Features/Mermaid%20Diagrams/","title":"Mermaid diagrams","text":"<p>Here's the example from MkDocs Material documentation: </p> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"Features/Text%20Formatting/","title":"Text Formatting","text":"<p>You can have lists like this</p> <ul> <li>first</li> <li>second</li> <li>third</li> </ul> <p>Or checklist lists to</p> <ul> <li> Get</li> <li> things</li> <li> done</li> </ul> <p>Also, get highlights and strikethroughs as above (similar to Obsidian).</p> <p>More formatting options for your webpage here. (but not compatible with Obsidian)</p>"},{"location":"Topic%201/Note%201/","title":"Note 1","text":"<p>Example: link to Mermaid Diagrams under <code>Features</code></p>"},{"location":"Topic%201/Note%202/","title":"Note 2","text":""},{"location":"blog/","title":"Blog","text":""}]}